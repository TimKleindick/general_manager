"""Infrastructure for expressing validation rules against GeneralManager instances."""

from __future__ import annotations
import ast
import inspect
import re
import textwrap
from typing import Callable, Dict, Generic, List, Optional, Tuple, TypeVar
from decimal import Decimal

from django.conf import settings
from django.utils.module_loading import import_string

from general_manager.rule.handler import (
    BaseRuleHandler,
    LenHandler,
    MaxHandler,
    MinHandler,
    SumHandler,
)
from general_manager.manager.generalManager import GeneralManager

GeneralManagerType = TypeVar("GeneralManagerType", bound=GeneralManager)


class MissingErrorTemplateVariableError(ValueError):
    """Raised when a custom error template omits required variables."""

    def __init__(self, missing: List[str]) -> None:
        super().__init__(
            f"The custom error message does not contain all used variables: {missing}."
        )


class ErrorMessageGenerationError(ValueError):
    """Raised when generating an error message before evaluating any input."""

    def __init__(self) -> None:
        super().__init__("No input provided for error message generation.")


class Rule(Generic[GeneralManagerType]):
    """
    Encapsulate a boolean predicate and derive contextual error messages from its AST.

    When the predicate evaluates to False, the rule inspects the parsed abstract syntax tree
    to determine which variables failed and crafts either autogenerated or custom error messages.
    """

    _func: Callable[[GeneralManagerType], bool]
    _custom_error_message: Optional[str]
    _ignore_if_none: bool
    _last_result: Optional[bool]
    _last_input: Optional[GeneralManagerType]
    _last_args: Dict[str, object]
    _param_names: Tuple[str, ...]
    _primary_param: Optional[str]
    _tree: ast.AST
    _variables: List[str]
    _handlers: Dict[str, BaseRuleHandler]

    def __init__(
        self,
        func: Callable[[GeneralManagerType], bool],
        custom_error_message: Optional[str] = None,
        ignore_if_none: bool = True,
    ) -> None:
        self._func = func
        self._custom_error_message = custom_error_message
        self._ignore_if_none = ignore_if_none
        self._last_result = None
        self._last_input = None
        self._last_args = {}

        parameters = inspect.signature(func).parameters
        self._param_names = tuple(parameters.keys())
        self._primary_param = self._param_names[0] if self._param_names else None

        # 1) Extract source, strip decorators, and dedent
        src = textwrap.dedent(inspect.getsource(func))

        # 2) Parse AST and attach parent references
        self._tree = ast.parse(src)
        for parent in ast.walk(self._tree):
            for child in ast.iter_child_nodes(parent):
                child.parent = parent

        # 3) Extract referenced variables
        self._variables = self._extract_variables()

        # 4) Register handlers
        self._handlers = {}  # type: Dict[str, BaseRuleHandler]
        for cls in (LenHandler, MaxHandler, MinHandler, SumHandler):
            inst: BaseRuleHandler = cls()
            self._handlers[inst.function_name] = inst
        for path in getattr(settings, "RULE_HANDLERS", []):
            handler_cls: type[BaseRuleHandler] = import_string(path)
            inst = handler_cls()
            self._handlers[inst.function_name] = inst

    @property
    def func(self) -> Callable[[GeneralManagerType], bool]:
        return self._func

    @property
    def customErrorMessage(self) -> Optional[str]:
        return self._custom_error_message

    @property
    def variables(self) -> List[str]:
        return self._variables

    @property
    def lastEvaluationResult(self) -> Optional[bool]:
        return self._last_result

    @property
    def lastEvaluationInput(self) -> Optional[GeneralManagerType]:
        return self._last_input

    @property
    def ignoreIfNone(self) -> bool:
        return self._ignore_if_none

    def evaluate(self, x: GeneralManagerType) -> Optional[bool]:
        """
        Execute the predicate against a manager instance and record the result.

        Parameters:
            x (GeneralManagerType): Manager instance supplied to the predicate.

        Returns:
            bool | None: True or False when the predicate executes; None when `ignore_if_none` is set and any referenced value is None.
        """
        self._last_input = x
        self._last_args = {}
        if self._primary_param is not None:
            self._last_args[self._primary_param] = x

        vals = self._extract_variable_values(x)
        if self._ignore_if_none and any(v is None for v in vals.values()):
            self._last_result = None
            return None

        self._last_result = self._func(x)
        return self._last_result

    def validateCustomErrorMessage(self) -> None:
        """
        Ensure the user-defined template references every extracted variable.

        Returns:
            None

        Raises:
            ValueError: If the custom error message omits a required placeholder.
        """
        if not self._custom_error_message:
            return

        vars_in_msg = set(re.findall(r"{([^}]+)}", self._custom_error_message))
        missing = [v for v in self._variables if v not in vars_in_msg]
        if missing:
            raise MissingErrorTemplateVariableError(missing)

    def getErrorMessage(self) -> Optional[Dict[str, str]]:
        """
        Build a mapping of variable names to error messages for the last evaluation.

        Returns:
            dict[str, str] | None: Mapping describing validation failures, or None when the predicate passed.

        Raises:
            ValueError: If called before any input has been evaluated.
        """
        if self._last_result or self._last_result is None:
            return None
        if self._last_input is None:
            raise ErrorMessageGenerationError()

        # Validate and substitute template placeholders
        self.validateCustomErrorMessage()
        vals = self._extract_variable_values(self._last_input)

        if self._custom_error_message:
            formatted = re.sub(
                r"{([^}]+)}",
                lambda m: str(vals.get(m.group(1), m.group(0))),
                self._custom_error_message,
            )
            return {v: formatted for v in self._variables}

        errors = self._generate_error_messages(vals)
        return errors or None

    def _extract_variables(self) -> List[str]:
        param_names = set(self._param_names)
        if not param_names:
            return []

        class VarVisitor(ast.NodeVisitor):
            def __init__(self, params: set[str]) -> None:
                self.vars: set[str] = set()
                self.params = params

            def visit_Attribute(self, node: ast.Attribute) -> None:
                parts: list[str] = []
                curr: ast.AST = node
                while isinstance(curr, ast.Attribute):
                    parts.append(curr.attr)
                    curr = curr.value
                if isinstance(curr, ast.Name) and curr.id in self.params:
                    self.vars.add(".".join(reversed(parts)))
                self.generic_visit(node)

        visitor = VarVisitor(param_names)
        visitor.visit(self._tree)
        return sorted(visitor.vars)

    def _extract_variable_values(
        self, x: GeneralManagerType
    ) -> Dict[str, Optional[object]]:
        out: Dict[str, Optional[object]] = {}
        for var in self._variables:
            obj: object = x  # type: ignore
            for part in var.split("."):
                obj = getattr(obj, part)
                if obj is None:
                    break
            out[var] = obj
        return out

    def _extract_comparisons(self) -> list[ast.Compare]:
        class CompVisitor(ast.NodeVisitor):
            def __init__(self) -> None:
                self.comps: list[ast.Compare] = []

            def visit_Compare(self, node: ast.Compare) -> None:
                self.comps.append(node)
                self.generic_visit(node)

        visitor = CompVisitor()
        visitor.visit(self._tree)
        return visitor.comps

    def _contains_logical_ops(self) -> bool:
        class LogicVisitor(ast.NodeVisitor):
            found: bool = False

            def visit_BoolOp(self, node: ast.BoolOp) -> None:
                if isinstance(node.op, (ast.And, ast.Or)):
                    self.found = True
                self.generic_visit(node)

        visitor = LogicVisitor()
        visitor.visit(self._tree)
        return visitor.found

    def _generate_error_messages(
        self, var_values: Dict[str, Optional[object]]
    ) -> Dict[str, str]:
        errors: Dict[str, str] = {}
        comparisons = self._extract_comparisons()
        logical = self._contains_logical_ops()

        if comparisons:
            for cmp in comparisons:
                left, rights, ops = cmp.left, cmp.comparators, cmp.ops
                for right, op in zip(rights, ops, strict=False):
                    # Special handler?
                    if isinstance(left, ast.Call):
                        fn = self._get_node_name(left.func)
                        handler = self._handlers.get(fn)
                        if handler:
                            errors.update(
                                handler.handle(cmp, left, right, op, var_values, self)
                            )
                            continue

                    # Standard error message
                    lnm = self._get_node_name(left)
                    rnm = self._get_node_name(right)
                    lval = self._eval_node(left)
                    rval = self._eval_node(right)
                    ldisp = f"[{lnm}] ({lval})" if lnm in var_values else str(lval)
                    rdisp = f"[{rnm}] ({rval})" if rnm in var_values else str(rval)
                    sym = self._get_op_symbol(op)
                    msg = f"{ldisp} must be {sym} {rdisp}!"
                    if lnm in var_values:
                        errors[lnm] = msg
                    if rnm in var_values and rnm != lnm:
                        errors[rnm] = msg

            if logical and not self._last_result:
                combo = ", ".join(f"[{v}]" for v in self._variables)
                msg = f"{combo} combination is not valid"
                for v in self._variables:
                    errors[v] = msg

            return errors

        # No comparisons present â†’ fall back to a generic message
        combo = ", ".join(f"[{v}]" for v in self._variables)
        return {v: f"{combo} combination is not valid" for v in self._variables}

    def _get_op_symbol(self, op: Optional[ast.cmpop]) -> str:
        if op is None:
            return "?"
        return {
            ast.Lt: "<",
            ast.LtE: "<=",
            ast.Gt: ">",
            ast.GtE: ">=",
            ast.Eq: "==",
            ast.NotEq: "!=",
            ast.Is: "is",
            ast.IsNot: "is not",
            ast.In: "in",
            ast.NotIn: "not in",
        }.get(type(op), "?")

    def _get_node_name(self, node: ast.AST) -> str:
        if isinstance(node, ast.Attribute):
            parts: list[str] = []
            curr: ast.AST = node
            while isinstance(curr, ast.Attribute):
                parts.insert(0, curr.attr)
                curr = curr.value
            return ".".join(parts)
        if isinstance(node, ast.Name):
            return node.id
        if isinstance(node, ast.Constant):
            return ""
        if isinstance(node, ast.Call):
            fn = self._get_node_name(node.func)
            args = ", ".join(self._get_node_name(a) for a in node.args)
            return f"{fn}({args})"
        try:
            # ast.unparse returns a string representation
            return ast.unparse(node)
        except (AttributeError, ValueError, TypeError):
            return ""

    def _eval_node(self, node: ast.expr) -> Optional[object]:
        """Evaluate an AST expression in the context of the last input."""
        if not isinstance(node, ast.expr):
            return None
        try:
            return ast.literal_eval(node)
        except (ValueError, TypeError):
            if isinstance(node, ast.Attribute):
                base = self._eval_node(node.value)
                if base is None:
                    return None
                return getattr(base, node.attr, None)
            if isinstance(node, ast.Name):
                if node.id in self._last_args:
                    return self._last_args[node.id]
                return self._func.__globals__.get(node.id)
            if isinstance(node, ast.UnaryOp) and isinstance(node.op, ast.USub):
                operand = self._eval_node(node.operand)
                if isinstance(operand, (int, float, Decimal)):
                    return -operand
        return None
