# Existing Model Interfaces

`ExistingModelInterface` (`general_manager.interface.existing_model_interface.ExistingModelInterface`) lets a manager wrap an existing Django model without generating new tables. It keeps the GeneralManager API intact—`create`, `update`, `deactivate`, factories, and history tracking all work the same—while pointing at the tables you already manage elsewhere.

## When to use it

- You have legacy Django models and want GeneralManager orchestration without migrating data into freshly generated tables.
- Multiple apps already depend on a model definition and you need the manager layer to stay backward compatible.
- You want to incrementally adopt managers before refactoring model code.

If you control the schema and prefer GeneralManager to build models for you, stick with [`DatabaseInterface`](db_based_interface.md).

## Pointing a manager at a legacy model

Reference the model with either an import or an app label string. Annotate the manager attributes you plan to read—GeneralManager derives field accessors from the legacy model instead of from interface field declarations.

```python
from django.contrib.auth import get_user_model

from general_manager.interface.existing_model_interface import ExistingModelInterface
from general_manager.manager import GeneralManager


class Customer(GeneralManager):
    id: int
    name: str
    notes: str | None

    class Interface(ExistingModelInterface):
        model = "crm.Customer"


```

The interface resolves `"crm.Customer"` through Django's app registry, registers the model with `django-simple-history` when needed, and links the manager back to the model via `_general_manager_class`. If you already have the model imported, assign the class directly instead of the string.

## Auditing and validation

- `create` and `update` assign `changed_by_id` when the model exposes that column and record `history_comment` values using `django-simple-history`.
- `deactivate` toggles `is_active` and appends `" (deactivated)"` to the provided history comment; make sure the legacy model exposes an `is_active` field if you plan to call it.
- Define `Meta.rules` on the interface to add GeneralManager validation alongside any rules already declared on the model. The interface merges both sets and replaces `full_clean()` so the rule set runs consistently everywhere.

## Writing data through the manager

`ExistingModelInterface` reuses the same write helpers as `DatabaseInterface`:

- Pass many-to-many identifiers with the `<relation>_id_list` convention or provide GeneralManager instances; the interface normalises and applies them after saving the main record.
- Foreign key assignments accept manager instances or raw IDs.
- `filter`, `exclude`, and `all` return manager instances backed by the legacy rows. You can query historical states by calling `ManagerInterface(search_date=...)` the same way you would with generated models.

No schema changes are generated by this interface—keep running your migrations and model definitions in the owning app.

## Factory support

An `AutoFactory` subclass is built automatically for each manager. It reuses any attributes you place on an inner `Factory` definition and populates missing fields using the legacy model metadata. Calling `Customer.Factory.create()` returns manager instances, so your tests keep existing fixtures while benefiting from the richer interface surface.

Looking for sample code? See the [Existing model interface cookbook recipes](../../examples/existing_model_interface.md) for end-to-end snippets you can drop into your project.
